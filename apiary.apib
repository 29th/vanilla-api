FORMAT: 1A

# Vanilla API

> This documentation is for the open source API shim for Vanilla (https://github.com/kasperisager/vanilla-api). For documentation on the official Simple API for the hosted version of Vanilla go to: http://docs.vanillaforums.com/api/

## Configuration

The API can be configured through the Vanilla dashboard using the "Application Interface" menu found in the "Forums Settings" section. Here you can see the main API endpoint and you can re-generate the application secret used for signature based authentication. Please be aware that there's no way for you to manually set the application secret in the dashboard - it enforces using a UUID v4 key which is a randomly generated, cryptographically secure string.

Should you wish to change the request expiration time or enable JSON and/or CORS, you can do this using the following configuration statements:

```php
$Configuration['API']['Expiration'] = strtotime('5 minutes', 0);
$Configuration['API']['AllowJSONP'] = false;
$Configuration['API']['AllowCORS']  = false;
```

## Authentication

Vanilla API supports two different authentication methods: A semi-stateless session based method as well as a stateless signature based method. The two are completely compatible so you are free to chose between one or other or use them both for different aspects of the same application. Both methods are also highly secure so you won't necessarily need to perform them over HTTPS although it _is_ highly recommended doing so.

### Session based

There's nothing too fancy about the session based authentication method from an API point of view: This method is in fact just the default Vanilla authentication. It is semi-stateless in the sense that when authenticating with the server, each client gets assigned a cookie which initiates a session. If a client accesses the API with a valid session, he or she can freely interface with Vanilla using the API, only restricted by their permissions.

Should you wish to use the session based authentication method, you'll need to use one of the many SSO solutions available for Vanilla to authenticate users from within your application. I have a custom SSO API class planned but it's not going to be ready anytime soon.

### Signature based

The signature based authentication method is similar to that used by [Amazon Web Services](http://aws.amazon.com/articles/1928#HTTP). To make an API call, you'll need 3 things: A public key, a private key and a signature (also referred to as _token_). The public key can be either the username or the email of the user making the request whilst the private key is an application secret generated for you upon enabling Vanilla API. The signature is an HMAC-SHA256 hash created by combining the public and the private key with any queries you want to pass along with your request and then signing it all with a Unix timestamp (UTC).

The request is then sent along to the server and the signature recreated using the information sent with the request. The server then compares its generated signature with the one from the request - if these match, then the client is considered legitimate and an authenticated session is started for the duration of the request.

#### Implementations

So far, the only implementation of the token generator is written in PHP - porting it to other languages should be pretty straight forward as the token generation is pretty simple, yet highly efficient. Let's take it by example...

Say we wanted to send the following request from our application to Vanilla:

```http
GET /api/endpoint/:id?query=value HTTP/1.1
```

This is of course just an abstraction of an actual HTTP request. Still, according to what we read earlier we'll need to also include a public key and a timestamp:

```http
GET /api/endpoint/:id?query=value&username=johndoe&email=example@mail.com&timestamp=[timestamp] HTTP/1.1
```

It's not required that you include both a username _and_ an email, but let's do it anyway. The request above would correspond to the following data array:

```php
$Request = [
    'query'     => 'value',
    'username'  => 'johndoe',
    'email'     => 'example@mail.com',
    'timestamp' => [timestamp]
];
```

Next up, the actual magic: An HMAC token. First off, we'll need to take our request apart as we'll need to do a little sorting of the request parameters so we're sure the token is generated the same way on both client and server. More specifically, we'll need to sort the parameters alphabetically after which we remove all the keys (we're only interested in the values) and delimit the values with a dash:

```php
// Sort the request data alphabetically
ksort($Request, SORT_STRING);

// Delimit the data values with a dash
implode('-', $Request)
```

Lastly, we can use the request data to generate an HMAC token using our application secret:

```php
$Token = hash_hmac('sha256', strtolower($Request), $Secret);
```

It's important that we lowercase the request data as to ensure consistent hash generation. We can now add the token to our request and send it off to the server:

```http
GET /api/endpoint/:id?query=value&username=johndoe&email=example@mail.com&timestamp=[timestamp]&token=[hash] HTTP/1.1
```

#### Security precautions

It is highly recommended to include the HTTP method as well the request URI in your query, and thus in the hash generation as well, as this can help prevent man-in-the-middle attacks where an attacker could potentially modify the endpoint you are operating on as well as the HTTP method.

## Extending

Vanilla API allows you to easily integrate your own plugins and applications with the API Mapper - it's as simple as creating a new API class and putting it anywhere in your application or plugin where the Garden autoloader can find it.

### API Classes

An API class is a small class that extends the abstract API Mapper and includes at least a `register()` method as defined by the API Interface. Endpoints are registered using the `get()`, `post()`, `put()` and `delete()` methods as outlined below:

```php
/**
 * Foo API
 *
 * Description of Foo API
 *
 * @package   [name]
 * @since     [version]
 * @author    [author] <[email]>
 * @copyright [description]
 * @license   [url] [description]
 */
class FooAPI extends APIMapper
{
    /**
     * Register API endpoints
     *
     * @since  [version]
     * @access protected
     * @param  array $data Request arguments passed along with the request
     * @return void
     * @static
     */
    protected static function register($data)
    {
        static::get('/[i:fooID]', [
            'application'  => 'Baz', // (Optional) Required in case of non-unique controller
            'controller'   => 'Foo', // (Required) The controller to operate on
            'method'       => 'bar', // (Optional) Defaults to `index`
            'authenticate' => true,  // (Optional) Defaults to `true` for all write-methods
            'arguments'    => []     // (Optional) Arguments to pass along to the method
        ]);
    }
}
```

Vanilla API uses [AltoRouter](https://github.com/dannyvankooten/AltoRouter) and passes along the named parameters as method arguments which in the above route would correspond to `$fooID`. Additional method arguments can be supplied in the `arguments` key. These can be mapped to user input via the `$data` array if needed.

### Extend existing class

To extend an existing API class, simply hook into the `register` event:

```php
/**
 * Foo Hooks
 *
 * @package   [name]
 * @since     [version]
 * @author    [author] <[email]>
 * @copyright [description]
 * @license   [url] [description]
 */
class FooHooks implements Gdn_IPlugin
{
    /**
     * Register extra Foo API endpoints
     *
     * @since  [version]
     * @access public
     * @param  FooAPI $sender The FooAPI instance
     * @return void
     * @static
     */
    public function FooAPI_register_handler($sender)
    {
        $sender::put('/bar/[i:fooID]', [...]);
    }
}
```

# Group Miscellaneous

## Configuration [/configuration]

### Get the current configuration [GET]

+ Response 200 (application/json)
    + Body
        {
            "Configuration": {
                ...
            }
        }

## Search [/search{?Search}]

### Perform a search [GET]

+ Parameters
    + Search (optional, string, `foo`) ... The search query.  

+ Response
    + Body
        {
            "SearchResults": [
                ...
            ],
            "SearchTerm": "foo",
            "SearchTerms": [
                ...
            ],
            "From": 1,
            "To": 29
        }

# Group Categories

## All [/categories]

### Find all categories [GET]

### Create a new category [POST]

+ Request
    + Body
        {
            "Name": "Foo Bar",
            "UrlCode": "foo-bar"
        }

+ Response 200 (application/json)

## Single [/categories/{category_id}]

+ Parameters
    + category_id (required, integer, `1`) ... The ID of the category.

### Find an existing category [GET]

+ Response 200 (application/json)

### Update an existing category [PUT]

+ Request
    + Body
        {
            "Name": "Foo Bar",
            "UrlCode": "foo-bar"
        }

+ Response 200 (application/json)

### Remove an existing category [DELETE]

+ Response 200 (application/json)

## Discussions [/categories/{category_id}/discussions]

+ Parameters
    + category_id (required, integer, `1`) ... The ID of the category.

### Create a new discussion [POST]

+ Request
    + Body
        {
            "Name": "Foo Bar",
            "Body": "Lorem ipsum dolor sit amet.",
            "Format": "Markdown"
        }

+ Response 200 (application/json)

# Group Discussions

## All [/discussions]

### Find all discussions [GET]

+ Response 200 (application/json)
    + Body
        {
            "Category": "123",
            "CountDiscussions": "123",
            "Announcements": [
                ...
            ],
            "Discussions": [
                ...
            ]
        }

### Create a new discussion [POST]

+ Request

    + Body
        {
            "Name": "Foo Bar",
            "Body": "Lorem ipsum dolor sit amet.".
            "CategoryID": 2
        }

+ Response 200 (application/json)
    
    The newly created discussion.

    + Body
        {
            "Discussion": {
                ...
            },
            "Type": "Discussion"
        }

## Single [/discussions/{discussion_id}]

+ Parameters
    + discussion_id (required, integer, `1`) ... The ID of the discussion.

### Find an existing discussion [GET]

+ Response 200 (application/json)
    The requested discussion if found and if the authorized user has permission to access it.

    + Body
        {
            "Category": {
                ...
            },
            "Discussion": {
                ...
            },
            "Page": "1"
        }
        
### Update an existing discussion [PUT]

+ Request

    + Body
        {
            "Name": "Foo Bar",
            "Body": "Lorem ipsum dolor sit amet.".
            "CategoryID": 2
        }
        
+ Response 200 (application/json)
    The updated discussion.

    + Body
        {
            "Discussion": {
                ...
            },
            "Type": "Discussion"
        }
        
### Remove an existing discussion [DELETE]

+ Response 200 (application/json)
    The discussion was removed successfully.
    
    + Body
        {}

## Comments [/discussions/{discussion_id}/comments]

+ Parameters
    + discussion_id (required, integer, `1`) ... The ID of the discussion.

### Create a new comment [POST]

+ Request
    + Body
        {
            "Body": "Lorem ipsum dolor amet.",
            "Format": "Markdown"
        }

+ Response 200 (application/json)
    The newly created comment.

    + Body
        {
            "Comment": {
                ...
            }
        }

## Comment [/discussions/{discussion_id}/comments/{comment_id}]

+ Parameters
    + discussion_id (required, integer, `1`) ... The ID of the discussion.
    + comment_id (required, integer, `1`) ... The ID of the comment.

### Update an existing comment [PUT]

+ Response 200 (application/json)
    The updated comment.

    + Body
        {
            "Comment": {
                ...
            }
        }

### Remove an existing comment [DELETE]

+ Response 200 (application/json)
    The comment was removed successfully.

    + Body
        {}

## Bookmarks [/discussions/bookmarks]

### Find own bookmarks [GET]

+ Response 200 (application/json)
    + Body
        {
            "CountDiscussions": "123",
            "Discussions": [
                ...
            ]
        }

## Own [/discussions/mine]

### Find own discussions [GET]

+ Response 200 (application/json)
    + Body
        {
        }

# Group Activities

## All [/activities]

### Find all activities [GET]

### Create a new activity [POST]

+ Request
    + Body
        {
            "Comment": ""
        }

## Single [/activities/{activity_id}]

+ Parameters
    + discussion_id (required, integer, `1`) ... The ID of the discussion.

### Find an existing activity [GET]

### Remove an existing activity [DELETE]

# Group Conversations

## All [/conversations]

### Find all conversations [GET]

+ Response 200 (application/json)

### Create a new conversation [POST]

+ Request
    + Body
        {
            "To": "",
            "Body": ""
        }

## Single [/conversations/{conversation_id}]

+ Parameters
    + discussion_id (required, integer, `1`) ... The ID of the discussion.
    
### Find an existing conversation [GET]

+ Response 200 (application/json)

### Remove an existing conversation [DELETE]

+ Response 200 (application/json)

### Create a new message [POST]

+ Request
    + Body
        {
            "Body": ""
        }

## Messages [/conversations/{conversation_id}/messages]

# Group Users

## All [/users]

### Create a new user [POST]

+ Request
    + Body
        {
            "Name": "",
            "Email": "",
            "Password": "",
            "RoleID": [0]
        }

+ Response 200 (application/json)

## Single [/users/{user_id}]

## Summary [/users/summary]

# Group Roles

## All [/roles]

### Create a new role [POST]

+ Request
    + Body
        {
            "Name": "Captain",
            "Permission": [
                ...
            ]
        }

## Single [/roles/{role_id}]